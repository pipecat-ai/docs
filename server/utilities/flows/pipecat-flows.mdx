---
title: "Pipecat Flows"
description: "Technical reference for Pipecatâ€™s conversation flow system"
---

<Tip>
  New to building conversational flows? Check out our [Pipecat Flows
  guide](/guides/features/pipecat-flows) first.
</Tip>

## Installation

<CodeGroup>

```bash Existing Pipecat installation
pip install pipecat-ai-flows
```

```bash Fresh Pipecat installation
# Basic installation
pip install pipecat-ai-flows

# Install Pipecat with required provider dependencies:
pip install "pipecat-ai[daily,openai,deepgram]"     # For OpenAI
pip install "pipecat-ai[daily,anthropic,deepgram]"  # For Anthropic
pip install "pipecat-ai[daily,google,deepgram]"     # For Google
```

</CodeGroup>

## Core Types

### FlowArgs

<ParamField path="FlowArgs" type="Dict[str, Any]">
  Type alias for function handler arguments.
</ParamField>

### FlowResult

<ResponseField name="FlowResult" type="TypedDict">
  Base type for function handler results. Additional fields can be included as needed.

  <Expandable title="Fields">
    <ResponseField name="status" type="str" optional>
      Optional status field
    </ResponseField>
    <ResponseField name="error" type="str" optional>
      Optional error message
    </ResponseField>
  </Expandable>
</ResponseField>

### FlowConfig

<ResponseField name="FlowConfig" type="TypedDict">
  Configuration for the entire conversation flow.

  <Expandable title="Fields">
    <ResponseField name="initial_node" type="str" required>
      Starting node identifier
    </ResponseField>
    <ResponseField name="nodes" type="Dict[str, NodeConfig]" required>
      Map of node names to configurations
    </ResponseField>
  </Expandable>
</ResponseField>

### NodeConfig

<ResponseField name="NodeConfig" type="TypedDict">
  Configuration for a single node in the flow.

  <Expandable title="Fields">
    <ResponseField name="role_messages" type="List[dict]">
      Defines the role or persona of the LLM. Required for the initial node and optional for subsequent nodes.

      ```python
      # Example role messages
      "role_messages": [
          {
              "role": "system",
              "content": "You are a helpful assistant..."
          }
      ],
      ```
    </ResponseField>
    <ResponseField name="task_messages" type="List[dict]" required>
      Defines the task for a given node. Required for all nodes.

      ```python
      # Example task messages
      "task_messages": [
          {
              "role": "system", # May be `user` depending on the LLM
              "content": "Ask the user for their name..."
          }
      ],
      ```
    </ResponseField>
    <ResponseField name="context_strategy" type="ContextStrategyConfig" optional>
      Strategy for managing context during transitions to this node.

      ```python
      # Example context strategy configuration
      "context_strategy": ContextStrategyConfig(
          strategy=ContextStrategy.RESET_WITH_SUMMARY,
          summary_prompt="Summarize the key points discussed so far."
      )
      ```
    </ResponseField>
    <ResponseField name="functions" type="List[dict]" required>
      LLM function / tool call, defined in the format for the specific LLM provider.

      In addition to the standard fields, the function call can also contain two special fields:
      - `handler`: a custom handler that executes when the function is called.
      - `transition_to`: for static flows, specifies the next node to transition to.
      - `transition_callback`: for dynamic flows, provides a handler to determine the next node.

      Note: A function cannot have both `transition_to` and `transition_callback`.

      ```python
      # Static flow example
      "functions": [
          {
              "type": "function",
              "function": {
                  "name": "get_current_movies",
                  "handler": get_movies,  # Optional custom handler
                  "description": "Fetch movies currently playing",
                  "parameters": {...},
                  "transition_to": "explore_movie"  # Static transition
              },
          }
      ]

      # Dynamic flow example
      "functions": [
          {
              "type": "function",
              "function": {
                  "name": "collect_age",
                  "handler": collect_age,  # Process the data
                  "description": "Collect user's age",
                  "parameters": {...},
                  "transition_callback": handle_age_transition  # Dynamic transition
              },
          }
      ]
      ```
    </ResponseField>
    <ResponseField name="pre_actions" type="List[dict]" optional>
      Actions that execute before the LLM inference. For example, you can send a message to the TTS to speak a phrase (e.g. "Hold on a moment..."), which may be effective if an LLM function call takes time to execute.

      ```python
      # Example pre_actions
      "pre_actions": [
          {
              "type": "tts_say",
              "text": "Hold on a moment..."
          }
      ],
      ```
    </ResponseField>
    <ResponseField name="post_actions" type="List[dict]" optional>
      Actions that execute after the LLM inference. For example, you can end the conversation.

      ```python
      # Example post_actions
      "post_actions": [
          {
              "type": "end_conversation"
          }
      ]
      ```
    </ResponseField>

  </Expandable>
</ResponseField>

### ContextStrategy

<ResponseField name="ContextStrategy" type="Enum">
  Strategy for managing conversation context during node transitions.

  <Expandable title="Values">
    <ResponseField name="APPEND" type="str">
      Default strategy. Adds new messages to existing context.
    </ResponseField>
    <ResponseField name="RESET" type="str">
      Clears context and starts fresh with new messages.
    </ResponseField>
    <ResponseField name="RESET_WITH_SUMMARY" type="str">
      Resets context but includes an AI-generated summary.
    </ResponseField>
  </Expandable>
</ResponseField>

### ContextStrategyConfig

<ResponseField name="ContextStrategyConfig" type="dataclass">
  Configuration for context management strategy.

{" "}

<Expandable title="Fields">
  <ResponseField name="strategy" type="ContextStrategy" required>
    The strategy to use for context management
  </ResponseField>
  <ResponseField name="summary_prompt" type="Optional[str]">
    Required when using RESET_WITH_SUMMARY. Prompt text for generating the
    conversation summary.
  </ResponseField>
</Expandable>

```python
# Example usage
config = ContextStrategyConfig(
    strategy=ContextStrategy.RESET_WITH_SUMMARY,
    summary_prompt="Summarize the key points discussed so far."
)
```

</ResponseField>

## FlowManager

<ResponseField name="FlowManager" type="class">
  Main class for managing conversation flows, supporting both static (configuration-driven) and dynamic (runtime-determined) flows.

  <Expandable title="Constructor Parameters">
    <ResponseField name="task" type="PipelineTask" required>
      Pipeline task for frame queueing
    </ResponseField>
    <ResponseField name="llm" type="LLMService" required>
      LLM service instance (OpenAI, Anthropic, or Google). Must be initialized with the corresponding pipecat-ai provider dependency installed.
    </ResponseField>
    <ResponseField name="context_aggregator" type="Any" required>
      Context aggregator used for pushing messages to the LLM service
    </ResponseField>
    <ResponseField name="tts" type="Optional[Any]">
      **Deprecated**: Optional TTS service for voice actions
    </ResponseField>
    <ResponseField name="flow_config" type="Optional[FlowConfig]">
      Optional static flow configuration
    </ResponseField>
    <ResponseField name="context_strategy" type="Optional[ContextStrategyConfig]">
      Optional configuration for how context should be managed during transitions.
      Defaults to APPEND strategy if not specified.
    </ResponseField>
  </Expandable>
</ResponseField>

### Methods

<ResponseField name="initialize" type="method">
  Initialize the flow with starting messages.

  <Expandable title="Raises">
    <ResponseField name="FlowInitializationError">
      If initialization fails
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="set_node" type="method">
  Set up a new conversation node.
  
  - For dynamic flows, the application must advance the conversation using `set_node` to set up the next node.
  - For static flows, `set_node` is triggered by a function call that contains a `transition_to` field.

<Expandable title="Parameters">
  <ResponseField name="node_id" type="str" required>
    Identifier for the new node
  </ResponseField>
  <ResponseField name="node_config" type="NodeConfig" required>
    Node configuration including messages, functions, and actions
  </ResponseField>
</Expandable>

  <Expandable title="Raises">
    <ResponseField name="FlowError">
      If node setup fails
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="register_action" type="method">
  Register a handler for a custom action type.

  <Expandable title="Parameters">
    <ResponseField name="action_type" type="str" required>
      String identifier for the action
    </ResponseField>
    <ResponseField name="handler" type="Callable" required>
      Async or sync function that handles the action
    </ResponseField>
  </Expandable>
</ResponseField>

<ResponseField name="get_current_context" type="method">
  Get the current conversation context.

Returns a list of messages in the current context, including system messages,
user messages, and assistant responses.

<Expandable title="Returns">
  <ResponseField name="messages" type="List[dict]">
    List of messages in the current context
  </ResponseField>
</Expandable>

<Expandable title="Raises">
  <ResponseField name="FlowError">
    If context aggregator is not available
  </ResponseField>
</Expandable>

Example usage:

```python
# Access current conversation context
context = flow_manager.get_current_context()

# Use in handlers
async def process_response(args: FlowArgs) -> FlowResult:
    context = flow_manager.get_current_context()
    # Process conversation history
    return {"status": "success"}
```

</ResponseField>

### State Management

The FlowManager provides a state dictionary for storing conversation data:

<CodeGroup>

```python Access state
flow_manager.state: Dict[str, Any]

# Store data
flow_manager.state["user_age"] = 25
```

```python Access in transitions
async def handle_transitions(
    function_name: str,
    args: Dict[str, Any],
    flow_manager: FlowManager
) -> None:
    age = flow_manager.state.get("user_age")
```

</CodeGroup>

### Function Results in State

Function results are automatically stored in the flow manager's state using the pattern `{function_name}_result`. This allows transition handlers to access function return values when making routing decisions.

<CodeGroup>

```python Function Handler
async def check_availability(args: FlowArgs) -> TimeResult:
    """Check if a time slot is available."""
    is_available = await check_third_party_api(args["time"])
    return TimeResult(
        status="success",
        available=is_available,
        time=args["time"]
    )
```

```python Transition Handler
async def handle_availability_check(args: Dict, flow_manager: FlowManager):
    """Access result from state to determine next node."""
    result = flow_manager.state["check_availability_result"]

    if result["available"]:
        await flow_manager.set_node("confirm", create_confirmation_node())
    else:
        await flow_manager.set_node("no_availability", create_no_availability_node())
```

</CodeGroup>

The function result is:

1. Returned from the function handler
2. Automatically stored in state
3. Available in the transition handler via `flow_manager.state`
4. Added to LLM context as a tool message

This pattern allows you to:

- Make routing decisions based on function results
- Access processed data in transition handlers
- Avoid redundant API calls

### Usage Examples

<CodeGroup>

```python Static Flow
flow_config: FlowConfig = {
    "initial_node": "greeting",
    "nodes": {
        "greeting": {
            "role_messages": [
                {
                    "role": "system",
                    "content": "You are a helpful assistant. Your responses will be converted to audio."
                }
            ],
            "task_messages": [
                {
                    "role": "system",
                    "content": "Start by greeting the user and asking for their name."
                }
            ],
            "functions": [{
                "type": "function",
                "function": {
                    "name": "collect_name",
                    "handler": collect_name_handler,     # Specify handler
                    "description": "Record user's name",
                    "parameters": {...},
                    "transition_to": "next_step"         # Specify transition
                }
            }]
        }
    }
}

# Create and initialize the FlowManager
flow_manager = FlowManager(
    task=task,
    llm=llm,
    context_aggregator=context_aggregator,
    flow_config=flow_config
)

# Initialize the flow_manager to start the conversation
await flow_manager.initialize()
```

```python Dynamic Flow
def create_initial_node() -> NodeConfig:
    return {
        "role_messages": [
            {
                "role": "system",
                "content": "You are a helpful assistant."
            }
        ],
        "task_messages": [
            {
                "role": "system",
                "content": "Ask the user for their age."
            }
        ],
        "functions": [
            {
                "type": "function",
                "function": {
                    "name": "collect_age",
                    "handler": collect_age,
                    "description": "Record user's age",
                    "parameters": {
                        "type": "object",
                        "properties": {
                            "age": {"type": "integer"}
                        },
                        "required": ["age"]
                    },
                    "transition_callback": handle_age_transition
                }
            }
        ]
    }

# Initialize the FlowManager
flow_manager = FlowManager(
    task=task,
    llm=llm,
    context_aggregator=context_aggregator,
)

await flow_manager.initialize()

# Initialize the flow_manager and set the initial node
@transport.event_handler("on_first_participant_joined")
async def on_first_participant_joined(transport, participant):
    await transport.capture_participant_transcription(participant["id"])
    await flow_manager.initialize()
    await flow_manager.set_node("initial", create_initial_node())
```

</CodeGroup>

<ResponseField name="Node Functions" type="concept">
  Functions that execute operations within a state.

<CodeBlock>

```python
from pipecat_flows import FlowArgs, FlowResult

async def process_data(args: FlowArgs) -> FlowResult:
    """Handle data processing within a node."""
    data = args["data"]
    result = await process(data)
    return {
        "status": "success",
        "processed_data": result
    }

# Node configuration with transition
{
    "type": "function",
    "function": {
        "name": "process_data",
        "handler": process_data,
        "description": "Process user data",
        "parameters": {
            "type": "object",
            "properties": {
                "data": {"type": "string"}
            }
        },
    }
}
```

</CodeBlock>

</ResponseField>

<ResponseField name="Edge Functions" type="concept">
  Functions that create transitions between nodes. Use `transition_to` (static flow) or `transition_callback` (dynamic flow) to specify the target node.

<CodeBlock>

```python
# Edge function configuration
{
    "type": "function",
    "function": {
        "name": "next_step",
        "description": "Transition to next node",
        "parameters": {"type": "object", "properties": {}},
        "transition_to": "target_node"  # Required: Specify target node (or use transition_callback for dynamic flows)
    }
}
```

</CodeBlock>

</ResponseField>

### Function Properties

<ResponseField name="handler" type="Optional[Callable]">
  
Async function that processes data within a node. Can be specified as:

- Direct function reference
- Either a Callable function or a string with `__function__:` prefix (e.g., `"__function__:process_data"`) to reference a function in the main script

<CodeGroup>
```python Direct Reference
{
    "type": "function",
    "function": {
        "name": "process_data",
        "handler": process_data,  # Callable function
        "parameters": {...}
    }
}
```

```python Function Token
{
    "type": "function",
    "function": {
        "name": "process_data",
        "handler": "__function__:process_data",  # References function in main script
        "parameters": {...}
    }
}
```

</CodeGroup>

</ResponseField>

<ResponseField name="transition_to" type="Optional[str]">
Name of the node to transition to after function execution. Used in static flows.

The presence of this property determines the function's behavior:

- Without `transition_to`: Node function that triggers immediate LLM completion upon result
- With `transition_to`: Edge function that triggers LLM completion after both function result and new node context are added

</ResponseField>

<ResponseField name="transition_callback" type="Optional[Callable]">
  Handler for dynamic flow transitions. Must be an async function with the signature:

```python
async def handle_transition(args: Dict[str, Any], flow_manager: FlowManager) -> None:
    """Handle transition to next node."""
    # Process args and determine next node
    await flow_manager.set_node("next", create_next_node())
```

The callback receives:

- `args`: Arguments from the function call
- `flow_manager`: Reference to the FlowManager instance

Example usage:

```python
async def handle_age_transition(args: Dict, flow_manager: FlowManager):
    age = args["age"]
    if age < 25:
        await flow_manager.set_node("young_adult", create_young_adult_node())
    else:
        await flow_manager.set_node("standard", create_standard_node())

# Use in function configuration
{
    "type": "function",
    "function": {
        "name": "collect_age",
        "handler": collect_age,
        "parameters": {...},
        "transition_callback": handle_age_transition
    }
}
```

Note: A function cannot have both `transition_to` and `transition_callback`.

</ResponseField>

### Handler Signatures

<CodeGroup>
    ```python With Arguments
    async def handler_with_args(args: FlowArgs) -> FlowResult:
        """Handler that processes arguments."""
        value = args["some_value"]
        return {
            "status": "success",
            "result": value
        }
    ```

    ```python Without Arguments
    async def handler_no_args() -> FlowResult:
        """Handler that doesn't need arguments."""
        result = await fetch_data()
        return {
            "status": "success",
            "data": result
        }
    ```

</CodeGroup>

### Return Types

<CodeGroup>
    ```python Success Response
    {
        "status": "success",
        "data": "some data"  # Optional additional data
    }
    ```

    ```python Error Response
    {
        "status": "error",
        "error": "Error message"
    }
    ```

</CodeGroup>

### Provider-Specific Formats

<Note>
  You don't need to handle these format differences manually - use the standard
  format and the FlowManager will adapt it for your chosen provider.
</Note>

<CodeGroup>
    ```python OpenAI
    {
        "type": "function",
        "function": {
            "name": "function_name",
            "handler": handler,
            "description": "Description",
            "parameters": {...}
        }
    }
    ```

    ```python Anthropic
    {
        "name": "function_name",
        "handler": handler,
        "description": "Description",
        "input_schema": {...}
    }
    ```

    ```python Google (Gemini)
    {
        "function_declarations": [
            {
                "name": "function_name",
                "handler": handler,
                "description": "Description",
                "parameters": {...}
            }
        ]
    }
    ```

</CodeGroup>

## Actions

`pre_actions` and `post_actions` are used to manage conversation flow. They are included in the `NodeConfig` and executed before and after the LLM function call, respectively.

Two categories of actions are available:

- Built-in actions: These actions ship with Flows by default.
- Custom actions: These are developer defined actions.

### Built-in Actions

Common actions shipped with Flows for managing conversation flow. To use them, just add them to your `NodeConfig`.

<ResponseField name="tts_say" type="action">
  Speaks text immediately using the TTS service.

<CodeBlock>

```python
"pre_actions": [
    {
        "type": "tts_say",
        "text": "Processing your request..."  # Required
    }
]
```

</CodeBlock>
</ResponseField>

<ResponseField name="end_conversation" type="action">
  Ends the conversation and closes the connection.

<CodeBlock>

```python
"post_actions": [
    {
        "type": "end_conversation",
        "text": "Goodbye!"  # Optional farewell message
    }
]
```

</CodeBlock>

</ResponseField>

### Custom Actions

You can define custom `pre_actions` and `post_actions`. They are registered automatically when included in the `NodeConfig`.

Custom actions are composed of:

<ResponseField name="action_type" type="str" required>
  String identifier for the action
</ResponseField>
<ResponseField name="handler" type="Callable" required>
  Async or sync function that handles the action
</ResponseField>

Example:

<CodeBlock>

```python
# Define custom action handler
async def custom_notification(action: dict):
    """Custom action handler."""
    message = action.get("message", "")
    await notify_user(message)

# Use in node configuration
"pre_actions": [
    {
        "type": "notify",
        "handler": send_notification
    }
]
```

</CodeBlock>

## Exceptions

<ResponseField name="FlowError" type="exception">
Base exception for all flow-related errors.

<CodeBlock>

```python
from pipecat_flows import FlowError

try:
    await flow_manager.set_node("invalid", config)
except FlowError as e:
    print(f"Flow error: {e}")
```

</CodeBlock>

</ResponseField>

<ResponseField name="FlowInitializationError" type="exception">
Raised when flow initialization fails.

<CodeBlock>

```python
from pipecat_flows import FlowInitializationError

try:
    await flow_manager.initialize()
except FlowInitializationError as e:
    print(f"Initialization failed: {e}")

```

</CodeBlock>

</ResponseField>

<ResponseField name="FlowTransitionError" type="exception">
Raised when a state transition fails.

<CodeBlock>

```python
from pipecat_flows import FlowTransitionError

try:
    await flow_manager.set_node("next", node_config)
except FlowTransitionError as e:
    print(f"Transition failed: {e}")

```

</CodeBlock>

</ResponseField>

<ResponseField name="InvalidFunctionError" type="exception">
Raised when an invalid or unavailable function is called.

<CodeBlock>

```python
from pipecat_flows import InvalidFunctionError

try:
await flow_manager.set_node("node", {
  "functions": [{
    "type": "function",
    "function": {
    "name": "invalid_function"
    }
  }]
})

except InvalidFunctionError as e:
    print(f"Invalid function: {e}")
```

</CodeBlock>

</ResponseField>
