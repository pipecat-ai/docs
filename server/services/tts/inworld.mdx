---
title: "Inworld"
description: "Text-to-speech service using Inworld AI's TTS APIs"
---

## Overview

Inworld AI provides high-quality text-to-speech synthesis with natural-sounding voices and real-time streaming capabilities. The service supports both streaming and non-streaming modes, making it suitable for various use cases from low-latency conversational AI to batch audio generation.

<Tip>
  Streaming mode is recommended for real-time applications requiring low
  latency.
</Tip>

<CardGroup cols={3}>
  <Card
    title="API Reference"
    icon="code"
    href="https://reference-server.pipecat.ai/en/latest/api/pipecat.services.inworld.tts.html"
  >
    Complete API documentation and method details
  </Card>
  <Card
    title="Inworld AI Docs"
    icon="book"
    href="https://docs.inworld.ai/docs/tts/tts"
  >
    Official Inworld TTS API documentation
  </Card>
  <Card
    title="Example Code"
    icon="play"
    href="https://github.com/pipecat-ai/pipecat/blob/main/examples/foundational/07ab-interruptible-inworld-http.py"
  >
    Working example with Inworld TTS
  </Card>
</CardGroup>

## Installation

To use Inworld services, no additional dependencies are required beyond the base installation:

```bash
pip install "pipecat-ai"
```

You'll also need to set up your Inworld API key as an environment variable: `INWORLD_API_KEY`.

<Tip>
  Get your API key from [Inworld Studio](https://studio.inworld.ai/). Make sure
  to base64-encode your API key.
</Tip>

## Frames

### Input

- `TextFrame` - Text content to synthesize into speech
- `TTSSpeakFrame` - Text that should be spoken immediately
- `TTSUpdateSettingsFrame` - Runtime configuration updates
- `LLMFullResponseStartFrame` / `LLMFullResponseEndFrame` - LLM response boundaries

### Output

- `TTSStartedFrame` - Signals start of synthesis
- `TTSAudioRawFrame` - Generated audio data (LINEAR16 PCM, WAV header stripped)
- `TTSStoppedFrame` - Signals completion of synthesis
- `ErrorFrame` - API or processing errors

## Features

- **High-Quality Voices**: Natural-sounding voices including Ashley, Hades, and more
- **Streaming & Non-Streaming**: Unified interface supporting both real-time and batch processing
- **Automatic Language Detection**: No need to specify language manually - Inworld detects it from your text
- **Voice Temperature Control**: Accepts 0-2 (best results 0.6 to 1.0); lower values yield steadier, deterministic speech, while higher values add expressive variation.
- **Model Selection**: Choose `inworld‑tts‑1` for real‑time, cost‑sensitive use (lowest latency); use `inworld‑tts‑1‑max` (experimental) when you can trade a bit more latency for richer expressiveness and broader multilingual support.
- **Professional-quality Audio Output**: LINEAR16 PCM audio at up to 48kHz

## Audio Markups

Inworld supports experimental audio markups for enhanced expressiveness in English:

**Emotion and Delivery Style** (use at beginning of text):

- **Emotions**: `[happy]`, `[sad]`, `[angry]`, `[surprised]`, `[fearful]`, `[disgusted]`
- **Delivery Styles**: `[laughing]`, `[whispering]`

**Non-verbal Vocalizations** (place anywhere in text):

- **Sound Effects**: `[breathe]`, `[clear_throat]`, `[cough]`, `[laugh]`, `[sigh]`, `[yawn]`

<Note>
  Audio markup features are experimental and currently support English only. For
  best results, use only one emotion/delivery style at the beginning of text.
  For detailed usage guidelines and best practices, refer to Inworld's
  documentation on [Audio Markups Best
  Practices](https://docs.inworld.ai/docs/tts/best-practices/generating-speech#audio-markups).
</Note>

## Usage Examples

### Streaming Mode (Real-time)

Perfect for conversational AI applications requiring low latency:

<CodeGroup>

```python Python
import asyncio
import aiohttp
import os
from pipecat.services.inworld.tts import InworldTTSService

async def main():
    async with aiohttp.ClientSession() as session:
        tts = InworldTTSService(
            api_key=os.getenv("INWORLD_API_KEY"),
            aiohttp_session=session,
            voice_id="Ashley",
            model="inworld-tts-1",
            streaming=True,  # Use streaming mode for real-time audio
            params=InworldTTSService.InputParams(
                temperature=0.8,
            ),
        )

        # Use in your pipeline
        # pipeline = Pipeline([...other_processors..., tts, ...])

asyncio.run(main())
```

</CodeGroup>

### Non-Streaming Mode (Complete Audio)

Ideal for scenarios where you need the complete audio file before playback:

<CodeGroup>

```python Python
tts = InworldTTSService(
    api_key=os.getenv("INWORLD_API_KEY"),
    aiohttp_session=session,
    voice_id="Hades",
    model="inworld-tts-1-max",  # Higher quality model
    streaming=False,  # Complete audio generation first
    params=InworldTTSService.InputParams(
        temperature=1.2,  # More expressive speech
    ),
)
```

</CodeGroup>

### Streaming vs Non-Streaming

| Mode              | Best For               | Use Cases                                                                                |
| ----------------- | ---------------------- | ---------------------------------------------------------------------------------------- |
| **Streaming**     | Real-time applications | Building conversational AI, minimal latency interactions, processing text as available   |
| **Non-Streaming** | Batch processing       | Longer content generation, complete audio files, batch scenarios, slighly better quality |

### Audio Specifications

- **Sample Rate Range**: 8kHz - 48kHz (default comes from StartFrame)
- **Bit Depth**: 16-bit
- **Encoding**: LINEAR16 PCM (uncompressed)
- **Format**: WAV headers automatically stripped

| Sample Rate | Quality | Use Case                         |
| ----------- | ------- | -------------------------------- |
| 16000 Hz    | Basic   | Voice calls, simple applications |
| 24000 Hz    | Good    | General conversational AI        |
| 48000 Hz    | High    | Professional applications, music |

## Monitoring and Metrics

- **Time To First Byte (TTFB)**: Latency measurement from request start to first audio chunk
- **Processing Time**: Total duration for the complete TTS operation
- **Usage Metrics**: Character count of processed text for billing and analytics

<Info>
  [Learn how to enable Metrics](/guides/features/metrics) in your Pipeline.
</Info>

## Resources

- [Inworld AI Documentation](https://docs.inworld.ai/)
- [TTS API Reference](https://docs.inworld.ai/api-reference/ttsAPI/texttospeech/)
- [Inworld Studio](https://studio.inworld.ai/) - Voice management and API keys
- [Audio Markups Best Practices](https://docs.inworld.ai/docs/tts/best-practices/generating-speech#audio-markups) - Techniques for optimal markup usage
- [Pipecat Examples](https://github.com/pipecat-ai/pipecat/tree/main/examples) - Sample implementations
