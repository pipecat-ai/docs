---
title: "Inworld"
---

import { CodeGroup } from "@/components/code-group"

# Inworld TTS

Inworld AI provides high-quality text-to-speech synthesis with natural-sounding voices and real-time streaming capabilities. The service supports both streaming and non-streaming modes, making it suitable for various use cases from low-latency conversational AI to batch audio generation.

## Features

- **High-Quality Voices**: Natural-sounding voices including Ashley, Hades, and more
- **Streaming & Non-Streaming**: Unified interface supporting both real-time and batch processing
- **Automatic Language Detection**: No need to specify language manually - Inworld detects it from your text
- **Voice Temperature Control**: Adjust synthesis variability for more natural speech patterns
- **Multiple Models**: Support for different TTS models including `inworld-tts-1` and `inworld-tts-1-max`
- **Professional Audio Quality**: LINEAR16 PCM audio at up to 48kHz sample rates

## Setup

### Prerequisites

1. **Inworld Account**: Sign up at [Inworld Studio](https://studio.inworld.ai/)
2. **API Key**: Get your Runtime API Key from Inworld Portal > Settings > API Keys
3. **Base64 Encoding**: Your API key should be base64-encoded for authentication

### Installation

The Inworld TTS service is included with Pipecat. No additional dependencies required.

### Environment Variables

Add your Inworld API key to your environment:

```bash
INWORLD_API_KEY=your_base64_encoded_api_key_here
```

## Quick Start

<CodeGroup>

```python Python
import asyncio
import aiohttp
import os
from pipecat.services.inworld.tts import InworldTTSService

async def main():
    async with aiohttp.ClientSession() as session:
        tts = InworldTTSService(
            api_key=os.getenv("INWORLD_API_KEY"),
            aiohttp_session=session,
            streaming=True,  # Use streaming mode for real-time audio
            params=InworldTTSService.InputParams(
                voice_id="Ashley",
                model="inworld-tts-1",
                temperature=0.8,
            ),
        )
        
        # Use in your pipeline
        # pipeline = Pipeline([...other_processors..., tts, ...])

asyncio.run(main())
```

</CodeGroup>

## Configuration

### Basic Parameters

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `api_key` | `str` | Required | Base64-encoded Inworld API key |
| `aiohttp_session` | `aiohttp.ClientSession` | Required | HTTP session for API requests |
| `streaming` | `bool` | `True` | Enable streaming mode for real-time audio |
| `sample_rate` | `int` | `None` | Audio sample rate (48000, 24000, 16000) |
| `encoding` | `str` | `"LINEAR16"` | Audio encoding format |

### Voice Parameters

Configure voice and model settings using `InworldTTSService.InputParams`:

| Parameter | Type | Default | Description |
|-----------|------|---------|-------------|
| `voice_id` | `str` | `"Ashley"` | Voice selection (Ashley, Hades, etc.) |
| `model` | `str` | `"inworld-tts-1"` | TTS model to use |
| `temperature` | `float` | `None` | Voice variability (0.0-2.0, optional) |

### Available Voices

Popular Inworld voices include:
- **Ashley**: Clear, professional female voice
- **Hades**: Deep, authoritative male voice
- And many more available in your Inworld account

For a complete list of available voices, see the [Inworld TTS Documentation](https://docs.inworld.ai/docs/tts/tts).

## Usage Examples

### Streaming Mode (Real-time)

Perfect for conversational AI applications requiring low latency:

<CodeGroup>

```python Python
tts = InworldTTSService(
    api_key=os.getenv("INWORLD_API_KEY"),
    aiohttp_session=session,
    streaming=True,  # Real-time audio chunks
    params=InworldTTSService.InputParams(
        voice_id="Ashley",
        model="inworld-tts-1",
        temperature=0.8,  # Add natural variability
    ),
)
```

</CodeGroup>

### Non-Streaming Mode (Complete Audio)

Ideal for scenarios where you need the complete audio file before playback:

<CodeGroup>

```python Python
tts = InworldTTSService(
    api_key=os.getenv("INWORLD_API_KEY"),
    aiohttp_session=session,
    streaming=False,  # Complete audio generation first
    params=InworldTTSService.InputParams(
        voice_id="Hades",
        model="inworld-tts-1-max",  # Higher quality model
        temperature=1.2,  # More expressive speech
    ),
)
```

</CodeGroup>

### Custom Audio Settings

Configure audio quality for your specific needs:

<CodeGroup>

```python Python
tts = InworldTTSService(
    api_key=os.getenv("INWORLD_API_KEY"),
    aiohttp_session=session,
    streaming=True,
    sample_rate=48000,  # High quality audio
    encoding="LINEAR16",  # Uncompressed PCM
    params=InworldTTSService.InputParams(
        voice_id="Ashley",
        model="inworld-tts-1",
    ),
)
```

</CodeGroup>

### Complete Pipeline Example

Here's a full example integrating Inworld TTS in a conversational AI pipeline:

<CodeGroup>

```python Python
import asyncio
import aiohttp
import os
from pipecat.pipeline.pipeline import Pipeline
from pipecat.services.inworld.tts import InworldTTSService
from pipecat.services.openai.llm import OpenAILLMService
from pipecat.services.openai.stt import OpenAISTTService
from pipecat.processors.aggregators.openai_llm_context import OpenAILLMContext

async def run_conversation():
    async with aiohttp.ClientSession() as session:
        # Configure services
        stt = OpenAISTTService(api_key=os.getenv("OPENAI_API_KEY"))
        
        tts = InworldTTSService(
            api_key=os.getenv("INWORLD_API_KEY"),
            aiohttp_session=session,
            streaming=True,
            params=InworldTTSService.InputParams(
                voice_id="Ashley",
                model="inworld-tts-1",
                temperature=0.8,
            ),
        )
        
        llm = OpenAILLMService(api_key=os.getenv("OPENAI_API_KEY"))
        
        # Set up conversation context
        messages = [
            {
                "role": "system",
                "content": "You are a helpful AI assistant. Keep responses concise and conversational."
            }
        ]
        
        context = OpenAILLMContext(messages)
        context_aggregator = llm.create_context_aggregator(context)
        
        # Build pipeline
        pipeline = Pipeline([
            # transport.input(),  # Your transport input
            stt,                  # Speech-to-text
            context_aggregator.user(),  # User message processing
            llm,                  # Language model
            tts,                  # Text-to-speech
            # transport.output(),  # Your transport output
            context_aggregator.assistant(),  # Assistant message processing
        ])

asyncio.run(run_conversation())
```

</CodeGroup>

## API Endpoints

The service automatically selects the appropriate Inworld API endpoint based on the streaming mode:

- **Streaming**: `https://api.inworld.ai/tts/v1/voice:stream`
- **Non-Streaming**: `https://api.inworld.ai/tts/v1/voice`

## Performance Considerations

### Streaming vs Non-Streaming

**Choose Streaming When:**
- Building real-time conversational applications
- Need minimal latency for user interactions
- Processing text as it becomes available

**Choose Non-Streaming When:**
- Generating audio for longer content
- Need complete audio files before playback
- Processing in batch scenarios

### Audio Quality Settings

| Sample Rate | Quality | Use Case |
|-------------|---------|----------|
| 16000 Hz | Basic | Voice calls, simple applications |
| 24000 Hz | Good | General conversational AI |
| 48000 Hz | High | Professional applications, music |

## Error Handling

Common issues and solutions:

### Authentication Errors
- Ensure your API key is properly base64-encoded
- Verify the key is active in your Inworld Portal
- Check environment variable is correctly set

### Connection Issues
- Ensure `aiohttp_session` is properly managed
- Use connection pooling for multiple requests
- Handle network timeouts appropriately

### Audio Processing
- WAV headers are automatically stripped for clean playback
- Empty audio chunks are filtered out
- Audio continuity is maintained to prevent clicks

## Monitoring and Metrics

The Inworld TTS service provides comprehensive metrics:

- **Time To First Byte (TTFB)**: Latency measurement
- **Usage Metrics**: Character count and model usage
- **Error Tracking**: Failed requests and error types

Enable metrics in your pipeline:

<CodeGroup>

```python Python
task = PipelineTask(
    pipeline,
    params=PipelineParams(
        enable_metrics=True,
        enable_usage_metrics=True,
    ),
)
```

</CodeGroup>

## Resources

- [Inworld AI Documentation](https://docs.inworld.ai/)
- [TTS API Reference](https://docs.inworld.ai/api-reference/ttsAPI/texttospeech/)
- [Inworld Studio](https://studio.inworld.ai/) - Voice management and API keys
- [Pipecat Examples](https://github.com/pipecat-ai/pipecat/tree/main/examples) - Sample implementations

For detailed API specifications and additional voice options, visit the [official Inworld TTS documentation](https://docs.inworld.ai/docs/tts/tts). 